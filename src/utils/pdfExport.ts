import { jsPDF } from 'jspdf';
import { User, FilterDimensions } from '@/types';

export interface ReportData {
  title: string;
  classification: string;
  generatedBy: User;
  generatedAt: Date;
  filters: FilterDimensions;
  sections: ReportSection[];
}

export interface ReportSection {
  title: string;
  content: string | ReportChart | ReportTable;
  type: 'text' | 'chart' | 'table' | 'kpi';
}

export interface ReportChart {
  type: 'bar' | 'line' | 'pie';
  data: any[];
  labels: string[];
}

export interface ReportTable {
  headers: string[];
  rows: string[][];
}

export interface KPIData {
  totalLeads: number;
  qualifiedLeads: number;
  enlistments: number;
  conversionRate: number;
  costPerLead: number;
  roas: number;
}

export class PDFExporter {
  private doc: jsPDF;
  private currentY: number = 20;
  private pageHeight: number = 297; // A4 height in mm
  private pageWidth: number = 210; // A4 width in mm
  private margin: number = 20;
  private lineHeight: number = 7;

  constructor() {
    this.doc = new jsPDF('portrait', 'mm', 'a4');
    this.setupFonts();
  }

  private setupFonts(): void {
    // Set default font
    this.doc.setFont('helvetica', 'normal');
  }

  private addClassificationBanner(classification: string = 'UNCLASSIFIED'): void {
    // Top banner
    this.doc.setFillColor(220, 53, 69); // Red color
    this.doc.rect(0, 0, this.pageWidth, 8, 'F');
    this.doc.setTextColor(255, 255, 255);
    this.doc.setFontSize(8);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(classification, this.pageWidth / 2, 5, { align: 'center' });

    // Bottom banner
    this.doc.rect(0, this.pageHeight - 8, this.pageWidth, 8, 'F');
    this.doc.text(classification, this.pageWidth / 2, this.pageHeight - 3, { align: 'center' });

    // Reset text color
    this.doc.setTextColor(0, 0, 0);
    this.currentY = 20;
  }

  private addHeader(title: string, user: User, generatedAt: Date): void {
    // Department seal/logo area (placeholder)
    this.doc.setFillColor(21, 101, 192); // Air Force blue
    this.doc.circle(35, 35, 10, 'F');
    this.doc.setTextColor(255, 255, 255);
    this.doc.setFontSize(8);
    this.doc.text('USAF', 35, 37, { align: 'center' });

    // Title
    this.doc.setTextColor(0, 0, 0);
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('AIR EDUCATION AND TRAINING COMMAND', 55, 30);
    
    this.doc.setFontSize(14);
    this.doc.text('RECRUITMENT ANALYTICS REPORT', 55, 37);

    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text(title, 55, 44);

    // Report metadata
    this.doc.setFontSize(9);
    this.doc.setTextColor(100, 100, 100);
    this.doc.text(`Generated by: ${user.name} (${user.role.displayName})`, this.margin, 55);
    this.doc.text(`Generated on: ${generatedAt.toLocaleDateString()} ${generatedAt.toLocaleTimeString()}`, this.margin, 61);
    
    // Add line separator
    this.doc.setDrawColor(200, 200, 200);
    this.doc.line(this.margin, 68, this.pageWidth - this.margin, 68);

    this.currentY = 75;
    this.doc.setTextColor(0, 0, 0);
  }

  private addSection(title: string, content: string): void {
    this.checkPageBreak(20);

    // Section title
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(title, this.margin, this.currentY);
    this.currentY += this.lineHeight + 2;

    // Section content
    this.doc.setFontSize(10);
    this.doc.setFont('helvetica', 'normal');
    
    const splitText = this.doc.splitTextToSize(content, this.pageWidth - 2 * this.margin);
    splitText.forEach((line: string) => {
      this.checkPageBreak(this.lineHeight);
      this.doc.text(line, this.margin, this.currentY);
      this.currentY += this.lineHeight;
    });

    this.currentY += 5; // Add spacing after section
  }

  private addKPIGrid(kpis: KPIData): void {
    this.checkPageBreak(60);

    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('KEY PERFORMANCE INDICATORS', this.margin, this.currentY);
    this.currentY += this.lineHeight + 5;

    const kpiItems = [
      { label: 'Total Leads', value: kpis.totalLeads.toLocaleString(), unit: '' },
      { label: 'Qualified Leads', value: kpis.qualifiedLeads.toLocaleString(), unit: '' },
      { label: 'Enlistments', value: kpis.enlistments.toString(), unit: '' },
      { label: 'Conversion Rate', value: kpis.conversionRate.toFixed(1), unit: '%' },
      { label: 'Cost per Lead', value: kpis.costPerLead.toString(), unit: '$' },
      { label: 'Return on Ad Spend', value: kpis.roas.toFixed(1), unit: 'x' }
    ];

    const colWidth = (this.pageWidth - 2 * this.margin) / 2;
    const rowHeight = 15;

    kpiItems.forEach((kpi, index) => {
      const col = index % 2;
      const row = Math.floor(index / 2);
      const x = this.margin + col * colWidth;
      const y = this.currentY + row * rowHeight;

      // KPI box
      this.doc.setFillColor(248, 249, 250);
      this.doc.rect(x, y - 3, colWidth - 5, rowHeight - 2, 'F');
      this.doc.setDrawColor(200, 200, 200);
      this.doc.rect(x, y - 3, colWidth - 5, rowHeight - 2, 'S');

      // KPI label
      this.doc.setFontSize(8);
      this.doc.setFont('helvetica', 'normal');
      this.doc.setTextColor(100, 100, 100);
      this.doc.text(kpi.label, x + 3, y + 2);

      // KPI value
      this.doc.setFontSize(14);
      this.doc.setFont('helvetica', 'bold');
      this.doc.setTextColor(0, 0, 0);
      this.doc.text(`${kpi.unit}${kpi.value}`, x + 3, y + 8);
    });

    this.currentY += Math.ceil(kpiItems.length / 2) * rowHeight + 10;
  }

  private addTable(headers: string[], rows: string[][]): void {
    const tableWidth = this.pageWidth - 2 * this.margin;
    const colWidth = tableWidth / headers.length;
    const rowHeight = 8;

    this.checkPageBreak((rows.length + 2) * rowHeight);

    // Table headers
    this.doc.setFillColor(21, 101, 192); // Air Force blue
    this.doc.rect(this.margin, this.currentY, tableWidth, rowHeight, 'F');
    
    this.doc.setTextColor(255, 255, 255);
    this.doc.setFontSize(9);
    this.doc.setFont('helvetica', 'bold');
    
    headers.forEach((header, index) => {
      this.doc.text(header, this.margin + index * colWidth + 2, this.currentY + 5);
    });

    this.currentY += rowHeight;

    // Table rows
    this.doc.setTextColor(0, 0, 0);
    this.doc.setFont('helvetica', 'normal');
    
    rows.forEach((row, rowIndex) => {
      // Alternate row colors
      if (rowIndex % 2 === 0) {
        this.doc.setFillColor(248, 249, 250);
        this.doc.rect(this.margin, this.currentY, tableWidth, rowHeight, 'F');
      }

      row.forEach((cell, colIndex) => {
        this.doc.text(cell, this.margin + colIndex * colWidth + 2, this.currentY + 5);
      });

      this.currentY += rowHeight;

      // Draw row separator
      this.doc.setDrawColor(200, 200, 200);
      this.doc.line(this.margin, this.currentY, this.margin + tableWidth, this.currentY);
    });

    this.currentY += 10; // Add spacing after table
  }

  private addFilterSummary(filters: FilterDimensions): void {
    const activeFilters: string[] = [];

    if (filters.service.length > 0) {
      activeFilters.push(`Service: ${filters.service.join(', ')}`);
    }
    if (filters.channel.length > 0) {
      activeFilters.push(`Channels: ${filters.channel.map(c => c.replace('_', ' ')).join(', ')}`);
    }
    if (filters.geography.region.length > 0) {
      activeFilters.push(`Regions: ${filters.geography.region.join(', ')}`);
    }
    if (filters.campaign.length > 0) {
      activeFilters.push(`Campaigns: ${filters.campaign.slice(0, 2).join(', ')}${filters.campaign.length > 2 ? '...' : ''}`);
    }

    if (activeFilters.length > 0) {
      this.addSection('APPLIED FILTERS', activeFilters.join('\n'));
    }
  }

  private checkPageBreak(requiredSpace: number): void {
    if (this.currentY + requiredSpace > this.pageHeight - 20) {
      this.doc.addPage();
      this.addClassificationBanner();
      this.currentY = 20;
    }
  }

  private addFooter(pageNumber: number, totalPages: number): void {
    this.doc.setFontSize(8);
    this.doc.setTextColor(100, 100, 100);
    this.doc.text(
      `Page ${pageNumber} of ${totalPages}`,
      this.pageWidth / 2,
      this.pageHeight - 15,
      { align: 'center' }
    );
    this.doc.text(
      'AETC Recruitment Analytics Dashboard',
      this.margin,
      this.pageHeight - 15
    );
    this.doc.text(
      new Date().toLocaleDateString(),
      this.pageWidth - this.margin,
      this.pageHeight - 15,
      { align: 'right' }
    );
  }

  public async generateExecutiveReport(
    user: User,
    filters: FilterDimensions,
    kpis: KPIData
  ): Promise<void> {
    this.addClassificationBanner('UNCLASSIFIED // FOR OFFICIAL USE ONLY');
    this.addHeader('Executive Summary Report', user, new Date());

    // Executive Summary
    this.addSection(
      'EXECUTIVE SUMMARY',
      `This report provides a comprehensive overview of AETC recruitment performance metrics. Key findings include ${kpis.totalLeads.toLocaleString()} total leads generated, resulting in ${kpis.enlistments} successful enlistments for a ${kpis.conversionRate.toFixed(1)}% conversion rate. The current cost per lead stands at $${kpis.costPerLead} with a return on advertising spend of ${kpis.roas.toFixed(1)}x.`
    );

    // KPI Grid
    this.addKPIGrid(kpis);

    // Performance Analysis
    this.addSection(
      'PERFORMANCE ANALYSIS',
      `Current recruitment efforts demonstrate ${kpis.roas >= 3 ? 'strong' : 'moderate'} performance with opportunities for optimization. The conversion rate of ${kpis.conversionRate.toFixed(1)}% ${kpis.conversionRate >= 7 ? 'exceeds' : 'meets'} target benchmarks. Cost efficiency metrics indicate ${kpis.costPerLead <= 80 ? 'excellent' : 'acceptable'} lead generation economics.`
    );

    // Filter Summary
    this.addFilterSummary(filters);

    // Recommendations
    this.addSection(
      'STRATEGIC RECOMMENDATIONS',
      `Based on current performance data, recommend: (1) ${kpis.roas >= 4 ? 'Scaling successful campaigns with increased budget allocation' : 'Optimizing underperforming channels to improve ROAS'}, (2) Implementing advanced targeting to reduce cost per lead, (3) Enhancing conversion processes to improve qualification rates, (4) Expanding geographic reach in high-performing regions.`
    );

    // Add footer to all pages
    const totalPages = (this.doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      this.doc.setPage(i);
      this.addFooter(i, totalPages);
    }

    // Save the PDF
    this.doc.save(`AETC_Executive_Report_${new Date().toISOString().split('T')[0]}.pdf`);
  }

  public async generateCampaignReport(
    user: User,
    filters: FilterDimensions,
    campaigns: any[]
  ): Promise<void> {
    this.addClassificationBanner('UNCLASSIFIED // FOR OFFICIAL USE ONLY');
    this.addHeader('Campaign Performance Report', user, new Date());

    // Campaign Overview
    this.addSection(
      'CAMPAIGN OVERVIEW',
      `This report analyzes ${campaigns.length} active recruitment campaigns across multiple channels. Total campaign investment of $${campaigns.reduce((sum, c) => sum + c.budget, 0).toLocaleString()} has generated ${campaigns.reduce((sum, c) => sum + c.leads, 0).toLocaleString()} leads and ${campaigns.reduce((sum, c) => sum + c.enlistments, 0)} enlistments.`
    );

    // Campaign Performance Table
    if (campaigns.length > 0) {
      this.doc.setFontSize(12);
      this.doc.setFont('helvetica', 'bold');
      this.doc.text('CAMPAIGN PERFORMANCE BREAKDOWN', this.margin, this.currentY);
      this.currentY += this.lineHeight + 5;

      const headers = ['Campaign', 'Channel', 'Budget', 'Leads', 'Enlistments', 'ROAS'];
      const rows = campaigns.slice(0, 10).map(campaign => [
        campaign.name.length > 25 ? campaign.name.substring(0, 25) + '...' : campaign.name,
        campaign.channel.replace('_', ' '),
        `$${(campaign.budget / 1000).toFixed(0)}K`,
        campaign.leads.toString(),
        campaign.enlistments.toString(),
        `${campaign.roas.toFixed(1)}x`
      ]);

      this.addTable(headers, rows);
    }

    // Filter Summary
    this.addFilterSummary(filters);

    // Channel Analysis
    const channelData = campaigns.reduce((acc, campaign) => {
      const channel = campaign.channel;
      if (!acc[channel]) {
        acc[channel] = { budget: 0, leads: 0, enlistments: 0, campaigns: 0 };
      }
      acc[channel].budget += campaign.budget;
      acc[channel].leads += campaign.leads;
      acc[channel].enlistments += campaign.enlistments;
      acc[channel].campaigns += 1;
      return acc;
    }, {} as Record<string, any>);

    let channelAnalysis = 'Channel performance breakdown:\n';
    Object.entries(channelData).forEach(([channel, data]: [string, any]) => {
      const convRate = ((data.enlistments / data.leads) * 100).toFixed(1);
      channelAnalysis += `â€¢ ${channel.replace('_', ' ').toUpperCase()}: ${data.campaigns} campaigns, ${data.leads} leads, ${convRate}% conversion\n`;
    });

    this.addSection('CHANNEL ANALYSIS', channelAnalysis);

    // Add footer to all pages
    const totalPages = (this.doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      this.doc.setPage(i);
      this.addFooter(i, totalPages);
    }

    // Save the PDF
    this.doc.save(`AETC_Campaign_Report_${new Date().toISOString().split('T')[0]}.pdf`);
  }
}

// Simple test function to verify PDF generation works
export const testPDFGeneration = (): void => {
  try {
    const doc = new jsPDF();
    doc.text('Test PDF Generation', 20, 20);
    doc.save('test.pdf');
    console.log('PDF generation successful');
  } catch (error) {
    console.error('PDF generation failed:', error);
  }
};

export const exportExecutivePDF = async (
  user: User,
  filters: FilterDimensions,
  kpis: KPIData
): Promise<void> => {
  try {
    console.log('Starting PDF export...', { user: user.name, kpis });
    const exporter = new PDFExporter();
    await exporter.generateExecutiveReport(user, filters, kpis);
    console.log('PDF export completed successfully');
  } catch (error) {
    console.error('PDF export failed:', error);
    throw error;
  }
};

export const exportCampaignPDF = async (
  user: User,
  filters: FilterDimensions,
  campaigns: any[]
): Promise<void> => {
  try {
    console.log('Starting campaign PDF export...', { user: user.name, campaigns: campaigns.length });
    const exporter = new PDFExporter();
    await exporter.generateCampaignReport(user, filters, campaigns);
    console.log('Campaign PDF export completed successfully');
  } catch (error) {
    console.error('Campaign PDF export failed:', error);
    throw error;
  }
};